# 정보처리 기사

## 1) 데이터베이스

널(NULL) 값: 아직 알려지지 않은 값이나 아직 모르는 값 = 정보 부재. (0이나 공백이 아니다!)

### SQL (Structured Query Language)

관계형 데이터베이스의 표준 질의어

#### DDL (Data Definition Language)

CREATE / ALTER / DROP [CASCADE | RESTRICT]

#### DML (Data Manipulation Language)

SELECT (튜플 검색, FROM, WHERE) / INSERT / DELETE / UPDATE (튜플 내용 변경)

```sql
// '대신공업사' '신촌상사'
SELECT * FROM 공급자 WHERE 공급자명 LIKE '%신%'
```





#### DCL (Data Control Language)

COMMIT (성공 선언) / ROLLBACK (실패 선언 후 결과 원상복귀) / GRANT (권한 부여) / REVOKE (권한 철회)



### Embedded SQL (내장 SQL)

#### 뷰 (View) - CREATE / SELECT / DROP

기본 테이블에서 유도된 가상 테이블

뷰 제거 시 그 뷰에서 유도된 다른 뷰 전부 제거됨!

뷰는 정의 변경 불가!

#### 시스템 카탈로그 (System Catalog = Data Dictionary)

뷰나 기본 테이블 등을 갖고 있는 시스템의 데이터베이스

사용자가 직접 갱신 불가! SQL 통해서 자동 갱신됨



### 트랜잭션 (Transaction)

연산의 집합!

원자성 (Atomicity): 트랜잭션은 한꺼번에 다 수행되어야 함. 하나라도 실패 시 취소

COMMIT / ROLLBACK



### 병행 제어 (Concurrency Control)

여러 트랜잭션 동시에 실행 (사용자 응답시간 최소화)

#### 로킹 (Locking), 로크 (Lock)

한 트랜잭션이 데이터에 접근하는 동안 다른 트랜잭션들은 그 데이터에 접근 불가!

##### 로킹 단위: 로킹의 대상이 되는 객체의 크기

로킹의 단위가 작아지면 병행성은 높아지나 로킹 오버헤드가 증가한다



### 암호화

#### 비밀키(private key) 암호화: 비밀번호로 잠그고 해제

예: DES (Data Encryption Standard)

#### 공개키(public key) 암호화: 비밀번호로 잠그고 아이디로 해제

예: RSA (Rivest, Shamir, Adleman) => 네트워크 데이터 전송에 활용됨!





### 자료구조

#### 스택 (Stack)

A, B, C, D 입력 시 가능한 출력

 예1) D, C, B, A

 예2) B, A, D, C

 예3) A, B, D, C



#### 큐 (Queue)



#### 데크 (Deque)



#### 트리 (Tree)

그래프의 특수한 형태

##### 용어

###### 근노드(Root node)

###### 단말 노드(Terminal node = Leaf)

###### 차수(Degree): 자식 노드의 수

###### 레벨(Level): 근노드에서 특정 노드까지 길이

###### 깊이(Depth): 최대 레벨



##### 이진 트리 (Binary tree)

차수가 2이하인 노드로 구성된 트리

###### 운행법 (Traversal) => 재귀적으로 생각해야 한다!★

전위 (Preorder): Parent -> Left Right

중위 (Inorder): Left -> Parent -> Right

후위(Postorder): Left -> Right -> Parent

```
예) (A * B) + (C * D)

​	전위: + *AB *CD

​	후위: AB* CD* +

​	중위: A*B + C*D
```



##### 이진 탐색 트리 (Binary search tree)

[6] 3 8 1 9 7 : 첫 노드가 근노드가 된다!

```
         [6]
   [3]         [8]
[1]         [7]   [9]
```



#### 그래프 (Graph)

정점(Vertex)과 간선(Edge)로 이루어짐

인접 행렬(Adjacent matrix)로 표현

신장 트리(Spanning Tree): 간선에 사이클이 없는 그래프





### 정렬

버블정렬
$$
k=[1,n] \\
a_k > a_{k+1} \text{ then } a_k \leftrightarrow a_{k+1}
$$


### 해싱

제산 (Division) / 중간 제곱 (Mid-square)  / 중첩 (Folding) / 기수 변환 (Radix Conversion) 등등

버킷 (Bucket): 주소를 담아두는 공간의 단위

충돌 (Collision): 다른 키값으로 동일한 해시값이 나오는 경우

Synonym: 충돌이 일어난 레코드들의 집합

#### 오버플로 해결

개방 주소 (Open Address = 선형 검색)

체이닝 (Chaining = 폐쇠 주소)

재해싱 (Rehashing)



## 2) 전자계산기 구조

### 불 대수 (Boolean Algebra)

#### 기호

$$
\begin{align}
A + B & \text{ (OR, 합집합)} \\
A \cdot B & \text{ (AND, 교집합)} \\
\overline{A} & \text{ (NOT)} \\
0 & \text{ (공집합)} \\
1 & \text{ (전체집합)}
\end{align}
$$

#### 분배법칙

$$
\begin {align}
A \cdot (B + C) & = A \cdot B + A \cdot C \\
A + (B \cdot C) & = (A + B) \cdot (A + C)
\end {align}
$$

#### 드모르간 법칙

$$
\begin {align}
\overline{A + B} & = \overline{A} \cdot \overline{B} \\
\overline{A \cdot B} & = \overline{A} + \overline{B}
\end {align}
$$



### 논리 게이트 (Logic Gate)

논리 회로를 구성하는 전자 소자

![](Asset\logic_gates.png)

### 자료의 표현 단위

비트: 정보 표현의 최소 단위

니블(nibble): 4비트 = 16진수 한 자리

바이트: 문자 표현의 최소 단위

워드(word): 컴퓨터 명령 단위 full word = 4byte

필드(field): 파일 구성의 최소 단위

레코드(record): 필드의 모임, 입출력 처리 단위

블록(block): 레코드의 모임

파일: 같은 종류의 레코드의 모임? 프로그램의 기본 구성 단위

데이터베이스: 파일의 모임



#### IEEE-754 부동소수점

부호 1비트 지수 8비트 가수 23비트 (배정도는 지수 11비트 가수 52비트)

여기서 지수란, 2의 거듭제곱을 이야기한다

지수부분 - 127을 해야 실제 지수가 나온다!

![](Asset\IEEE754.png)

```cpp
// [IEEE-754]
//
// case #0
// ┌───────┐
// │  dec  │
// ├───────┤
// │   0   │
// └───────┘
//  │      ┌───┬─────────┬─────────────────────────────┐
//  │      │sgn│   exp   │           fraction          │
//  └────→ ├───┼─────────┼─────────────────────────────┤
//         │ 0 │0000 0000│0000 0000 0000 0000 0000 000 │
//         └───┴─────────┴─────────────────────────────┘
// case #1
// ┌───────┬───┬───────┬───┬─────────────────────┬────────────────────────────────────┐
// │  dec  │   │  bin  │   │     encoded bin     │                result              │
// ├───────┼───┼───────┼───┼─────────────────────┼────────────────────────────────────┤
// │  1.0  │ = │ 1.0   │ = │ (1 + 0.0) * 2^(0)   │ sgn[0] exp[127 + 0] fraction [0]   │
// └───────┴───┴───────┴───┴─────────────────────┴────────────────────────────────────┘
//  │      ┌───┬─────────┬─────────────────────────────┐
//  │      │sgn│   exp   │           fraction          │
//  └────→ ├───┼─────────┼─────────────────────────────┤
//         │ 0 │0111 1111│0000 0000 0000 0000 0000 000 │
//         └───┴─────────┴─────────────────────────────┘
// case #2
// ┌───────┬───┬───────┬───┬─────────────────────┬────────────────────────────────────┐
// │  dec  │   │  bin  │   │     encoded bin     │                result              │
// ├───────┼───┼───────┼───┼─────────────────────┼────────────────────────────────────┤
// │  1.5  │ = │ 1.1   │ = │ (1 + 0.1) * 2^(0)   │ sgn[0] exp[127 + 0] fraction [1]   │
// └───────┴───┴───────┴───┴─────────────────────┴────────────────────────────────────┘
//  │      ┌───┬─────────┬─────────────────────────────┐
//  │      │sgn│   exp   │           fraction          │
//  └────→ ├───┼─────────┼─────────────────────────────┤
//         │ 0 │0111 1111│1000 0000 0000 0000 0000 000 │
//         └───┴─────────┴─────────────────────────────┘
// case #3
// ┌───────┬───┬───────┬───┬─────────────────────┬────────────────────────────────────┐
// │  dec  │   │  bin  │   │     encoded bin     │                result              │
// ├───────┼───┼───────┼───┼─────────────────────┼────────────────────────────────────┤
// │  0.5  │ = │ 0.1   │ = │ (1 + 0.0) * 2^(-1)  │ sgn[0] exp[127 - 1] fraction [0]   │
// └───────┴───┴───────┴───┴─────────────────────┴────────────────────────────────────┘
//  │      ┌───┬─────────┬─────────────────────────────┐
//  │      │sgn│   exp   │           fraction          │
//  └────→ ├───┼─────────┼─────────────────────────────┤
//         │ 0 │0111 1110│0000 0000 0000 0000 0000 000 │
//         └───┴─────────┴─────────────────────────────┘                       
// case #4
// ┌───────┬───┬───────┬───┬─────────────────────┬────────────────────────────────────┐
// │  dec  │   │  bin  │   │     encoded bin     │                result              │
// ├───────┼───┼───────┼───┼─────────────────────┼────────────────────────────────────┤
// │  2.75 │ = │ 10.11 │ = │ (1 + 0.011) * 2^(1) │ sgn[0] exp[127 + 1] fraction [011] │
// └───────┴───┴───────┴───┴─────────────────────┴────────────────────────────────────┘
//  │      ┌───┬─────────┬─────────────────────────────┐
//  │      │sgn│   exp   │           fraction          │
//  └────→ ├───┼─────────┼─────────────────────────────┤
//         │ 0 │1000 0000│0110 0000 0000 0000 0000 000 │
//         └───┴─────────┴─────────────────────────────┘
// case #5
// ┌───────┐
// │  dec  │
// ├───────┤
// │ -2.75 │
// └───────┘
//  │      ┌───┬─────────┬─────────────────────────────┐
//  │      │sgn│   exp   │           fraction          │
//  └────→ ├───┼─────────┼─────────────────────────────┤
//         │ 1 │1000 0000│0110 0000 0000 0000 0000 000 │
//         └───┴─────────┴─────────────────────────────┘
```



### 자료의 표현

#### BCD 코드 (Binary Coded Decimal Code)

10진수 한 자리를 4바이트로

##### 3-초과 코드 (Excess-3 Code)

BCD코드 + 3

##### 그레이 코드 (Gray Code)

BCD의 인접 비트를 XOR (맨 첫 비트만 그대로)

#### 해밍 코드 (Hamming Code)

1, 2, 4, 8 ... 번 비틍 패리티 비트 삽입 => 에러 검출, 교정이 가능!

##### 해밍 거리: 두 코드에서 서로 다른 값의 개수



### 진법 변환

$$
\begin{align}
BC.D_{(16)} & \\
& = \phantom{ab} 1011 \ 1100 \ . \ 1101 _{(2)} \\
& = \ 010 \ 111 \ 100 \ . \ 110\ 100 _{(2)} \\
& = \ 274.64 _{(8)}
\end{align}
$$



### 보수 변환

#### 1의 보수: 0을 1로, 1을 0으로

#### 2의 보수: 1의보수 + 1



### 인터럽트

외부 인터럽트: 전원 이상, 기계 이상, 외부 신호, 입출력

내부 인터럽트: overflow, underflow, division by 0

소프트웨어 인터럽트: 프로그램

SVC 인터럽트 (SuperVisor Call)



## 3) 운영체제

### 발달사

일괄 처리 (batch processing) -> 다중 프로그래밍 -> 다중 처리(Multi-processing = multi-tasking) -> 시분할(Time Sharing)  / 실시간 -> 다중 모드 -> 분산 처리



### 프로세스

병행 프로세스 Concurrent process

#### 임계 구역 (Critical Section)

#### 세마포어 (Semaphore): Dikstra가 제안.

#### 모니터 (Monitor): 한 번에 하나의 프로세스만 진입 가능

#### 교착 상태 (Deadlock)



### 스케쥴링 (Scheduling)

#### 비선점 스케쥴링(Non-preemptive) - 평등

FCFS (First Come First Served) = FIFO

SJF (Shortest Job First)

우선순위 (Priority)

#### 선점 스케쥴링 - 새치기 있음

SRT (Shortest Remaining Time)

RR (Round Robin): 할당된 시간만큼만 CPU 사용

##### 컨텍스트 스위칭 (Context Switching) => 오버헤드

현재 CPU를 사용 중인 프로세스의 상태 저장

#### 평균 반환 시간 = 평균 실행 시간 + 평균 대기 시간



### 주기억장치

#### 단편화 (Fragmentation)

내부 단편화: 할당 쓸데없이 크게 해서 공간 낭비됨

외부 단편화: 공간들이 잘게 잘려서 큰 공간을 할당 못함

#### 가상 기억 장치 (virtual memory)

페이징(Paging): 프로그램을 동일한 크기로 나눠서 (Page) 적재 -> Page Map Table 필요

세그멘테이션(Segmentation): 다양한 크기로 나눠서 (Segment) 적재 -> Segment Map Table 필요

#### 페이지 폴트 (Page fault)

참조할 페이지가 적재 안 되어 있는 상태. 새로 페이지를 불러오려면 기존 페이지 중 하나는 버려야 함

OPT (Optimal replacement): 가장 오래 사용 안 '될' 페이지와 교체

FIFO: 가장 예전에 적재된 페이지와 교체

LRU (Least Recently Used): 가장 예전에 사용된 페이지와 교체

LFU (Least Frequently Used): 가장 덜 사용된 페이지와 교체

#### 구역성 (Locality): 페이지 집중 참조 현상

시간 구역성: 최근에 쓴 애가 또 쓰일 가능성이 높아

공간 구역성: 가까이 붙어있는 애들이 서로 같이 쓰일 가능성이 높아

#### 워킹 셋 (Working set)

구역성을 활용한 페이지의 집합

#### 스래싱 (Thrashing)

페이지 폴트가 너무 심해서 프로그램 수행보다 페이지 이동이 더 오래 걸리는 현상



### 유닉스 (UNIX)

#### 구조

커널 (Kernel): 하드웨어 캡슐화, 시스템 호출 인터페이스 등

셸 (Shell): 명령어 해석기, 사용자 - 시스템 인터페이스

유틸리티: 사용자 편의를 위한 프로그램

#### 파일 시스템

디렉터리 = 트리 구조

#### 명령어

fork: 프로세스 생성 및 복제

cat [con**cat**enate]

##### chmod [change mode]

$$
\begin{align}
&[nnn_{(8)}]\text{= rwx}\\
\text{chmod } & \text{[user][group][others]} \\ \\
\text{chmod } & \text{754 (= chmod [rwx][r-x][r--])}
\end{align}
$$

ls [**l**i**s**t]

fsck [**f**ile **s**ystem **c**onsistency chec**k**]



## 4) 소프트웨어 공학

### 객체지향 (Object-Oriented)

#### 객체(Object): Attribute(=Data) + Method(=Function, Procedure)

#### 클래스(Class): 추상화된 데이터

#### 캡슐화(Encapsulation): 데이터+연산(Operation)



## 5) 데이터 통신

### 통신 매체

#### 트위스트 페어 (Twisted Pair)

#### 광섬유 케이블 (Optical Fiber Cable)



### OSI 모형 (Open Systems Interconnection model)

#### 7계층: 물리 계층 - 데이터 링크 계층 - 네트워크 계층 - 전송 계층 - 세션 계층 - 표현 계층 - 응용 계층

데이터 링크: **물리 주소**

네트워크 계층: IP (Internet Protocol)

전송 계층: TCP (Transmission Control Protocol) / UDP (User Datagram Protocol)